import {
  compressionIRLE,
  hammingCodesIntegerToBinary,
  compressionIILZ,
} from './solvers.js'

export async function main(ns) {
  ns.disableLog("ALL");
  // This script could run separately in a loop, howeverit is more RAM-efficient to call the script from a management script
  //while (true) {
  // get all available servers
  const servers = getAllServers(ns)
  const contracts = servers.flatMap((server) => {
    const onServer = ns.ls(server, ".cct").map((contract) => {
      const type = ns.codingcontract.getContractType(contract, server);
      const data = ns.codingcontract.getData(contract, server);
      const didSolve = solve(type, data, server, contract, ns);
      return `${server} - ${contract} - ${type} - ${didSolve || "FAILED!"}`;
    });
    return onServer;
  });
  // ns.tprint("Found " + contracts.length + " contracts");
  contracts.forEach((contract) => void ns.tprint(contract));
  // sleep in case this script is run manually
  //await ns.sleep(60000)
  //}
  return;
}

function getAllServers(ns) {
  var q = [];
  var serverDiscovered = [];

  q.push("home");
  serverDiscovered["home"] = true;

  while (q.length) {
    let v = q.shift();

    let edges = ns.scan(v);

    for (let i = 0; i < edges.length; i++) {
      if (!serverDiscovered[edges[i]]) {
        serverDiscovered[edges[i]] = true;
        q.push(edges[i]);
      }
    }
  }
  //delete serverDiscovered["home"];
  return Object.keys(serverDiscovered);
}

function solve(type, data, server, contract, ns) {
  let solution = "";
  //ns.tprint(type);
  switch (type) {
    case "Algorithmic Stock Trader I":
      solution = maxProfit([1, data]);
      break;
    case "Algorithmic Stock Trader II":
      solution = maxProfit([Math.ceil(data.length / 2), data]);
      break;
    case "Algorithmic Stock Trader III":
      solution = maxProfit([2, data]);
      // solution = stockMarketProfit(data, 2)
      break;
    case "Algorithmic Stock Trader IV":
      solution = maxProfit(data);
      break;
    case "Minimum Path Sum in a Triangle":
      solution = solveTriangleSum(data, ns);
      break;
    case "Unique Paths in a Grid I":
      solution = uniquePathsI(data);
      break;
    case "Unique Paths in a Grid II":
      solution = uniquePathsII(data);
      break;
    case "Generate IP Addresses":
      solution = generateIps(data);
      break;
    case "Find Largest Prime Factor":
      solution = factor(data);
      break;
    case "Spiralize Matrix":
      solution = spiral(data);
      break;
    case "Merge Overlapping Intervals":
      solution = mergeOverlap(data);
      break;
    case "Array Jumping Game":
      solution = solverArrayJumpingGame(data);
      break;
    case "Array Jumping Game II":
      solution = "";
      break;
    case "Find All Valid Math Expressions":
      //solution = await findAllValidMathExpressions(data, ns);
      solution = solverWaysToExpress(data);
      break;
    case "Subarray with Maximum Sum":
      solution = solverLargestSubset(data);
      break;
    case "Total Ways to Sum":
      solution = solverWaysToSum(data);
      break;
    case "Total Ways to Sum II":
      solution = "";
      break;
    case "Sanitize Parentheses in Expression":
      solution = removeInvalidParenthesis(data);
      break;
    case "Compression I: RLE Compression":
      solution = compressionIRLE(data);
      break;
    case "Compression II: LZ Decompression":
      solution = compressionIILZ(data);
      break;
    case "Compression III: LZ Compression":
      solution = "" //compressionIILZ(data);
      break;
    case "HammingCodes: Integer to Encoded Binary":
      solution = "";
      break;
    case "HammingCodes: Encoded Binary to Integer":
      solution = "";
      break;
    case "Shortest Path in a Grid":
      solution = "";
      break;
    case "Proper 2-Coloring of a Graph":
      solution = "";
      break;
    default:
      return false;
  }
  return (solution !== "") ? ns.codingcontract.attempt(solution, contract, server, [true]) : "";
}

// Sanitize Parentheses in Expression

// method checks if character is parenthesis(open or closed)
function isParenthesis(c) {
  return ((c == '(') || (c == ')'));
}

// method returns true if string contains valid parenthesis
function isValidString(str) {
  let cnt = 0;
  for (let i = 0; i < str.length; i++) {
    if (str[i] == '(')
      cnt++;
    else if (str[i] == ')')
      cnt--;
    if (cnt < 0)
      return false;
  }
  return (cnt == 0);
}

// method to remove invalid parenthesis
function removeInvalidParenthesis(str) {
  if (str.length == 0)
    return [];

  // visit set to ignore already visited string
  let visit = new Set();

  // queue to maintain BFS
  let q = [];
  let temp;
  let level = false;
  let solutions = []

  // pushing given string as starting node into queue
  q.push(str);
  visit.add(str);
  while (q.length != 0) {
    str = q.shift();
    if (isValidString(str)) {
      solutions.push(str);

      // If answer is found, make level true
      // so that valid string of only that level
      // are processed.
      level = true;
    }
    if (level)
      continue;
    for (let i = 0; i < str.length; i++) {
      if (!isParenthesis(str[i]))
        continue;

      // Removing parenthesis from str and
      // pushing into queue,if not visited already
      temp = str.substring(0, i) + str.substring(i + 1);
      if (!visit.has(temp)) {
        q.push(temp);
        visit.add(temp);
      }
    }
  }
  if (solutions.length == 0) {
    solutions.push("");
  }
  return solutions;
}

// Total Ways to Sum

function solverWaysToSum(arrayData) {
  var ways = [];
  ways[0] = 1;

  for (var a = 1; a <= arrayData; a++) {
    ways[a] = 0;
  }

  for (var i = 1; i <= arrayData - 1; i++) {
    for (var j = i; j <= arrayData; j++) {
      ways[j] += ways[j - i];
    }
  }

  return ways[arrayData];
}

// Subarray with Maximum Sum

function solverLargestSubset(arrayData) {
  let highestSubset = arrayData[0];

  for (let i = 0; i < arrayData.length; i++) {

    for (let j = i; j < arrayData.length; j++) {
      let tempSubset = 0;
      for (let k = i; k <= j; k++) {
        tempSubset += arrayData[k];
      }

      if (highestSubset < tempSubset) {
        highestSubset = tempSubset;
      }
    }
  }

  return highestSubset;
}

// Find All Valid Math Expressions

function solverWaysToExpress(arrayData) {
  //ns.tprint("solverWaysToExpress()");
  //await ns.sleep(1000);
  let i, j, k;

  let operatorList = ["", "+", "-", "*"];
  let validExpressions = [];

  let tempPermutations = Math.pow(4, (arrayData[0].length - 1));

  for (i = 0; i < tempPermutations; i++) {

    //if (!Boolean(i % 100000)) {
    //    ns.tprint(i + "/" + tempPermutations + ", " + validExpressions.length + " found.");
    //    await ns.sleep(100);
    //}

    let arraySummands = [];
    let candidateExpression = arrayData[0].substr(0, 1);
    arraySummands[0] = parseInt(arrayData[0].substr(0, 1));

    for (j = 1; j < arrayData[0].length; j++) {
      candidateExpression += operatorList[(i >> ((j - 1) * 2)) % 4] + arrayData[0].substr(j, 1);

      let rollingOperator = operatorList[(i >> ((j - 1) * 2)) % 4];
      let rollingOperand = parseInt(arrayData[0].substr(j, 1));

      switch (rollingOperator) {
        case "":
          rollingOperand = rollingOperand * (arraySummands[arraySummands.length - 1] / Math.abs(arraySummands[arraySummands.length - 1]));
          arraySummands[arraySummands.length - 1] = arraySummands[arraySummands.length - 1] * 10 + rollingOperand;
          break;
        case "+":
          arraySummands[arraySummands.length] = rollingOperand;
          break;
        case "-":
          arraySummands[arraySummands.length] = 0 - rollingOperand;
          break;
        case "*":
          while (j < arrayData[0].length - 1 && ((i >> (j * 2)) % 4) === 0) {
            j += 1;
            candidateExpression += arrayData[0].substr(j, 1);
            rollingOperand = rollingOperand * 10 + parseInt(arrayData[0].substr(j, 1));
          }
          arraySummands[arraySummands.length - 1] = arraySummands[arraySummands.length - 1] * rollingOperand;
          break;
      }
    }

    let rollingTotal = arraySummands.reduce(function (a, b) { return a + b; });

    //if(arrayData[1] == eval(candidateExpression)){
    if (arrayData[1] === rollingTotal) {
      validExpressions[validExpressions.length] = candidateExpression;
    }
  }

  return JSON.stringify(validExpressions);
}

// Array Jumping Game

function solverArrayJumpingGame(arrayData) {
  let arrayJump = [0];

  for (let n = 0; n < arrayData.length; n++) {
    if (arrayJump[n] || !n) {
      for (let p = n; p <= Math.min(n + arrayData[n], arrayData.length - 1); p++) {
        arrayJump[p] = 1;
      }
    }
  }
  //tprint("Array Jumping Game: " + 0 + Boolean(arrayJump[arrayData.length - 1]));
  return 0 + Boolean(arrayJump[arrayData.length - 1]);
}

//ALGORITHMIC STOCK TRADER

function maxProfit(arrayData) {
  let i, j, k;

  let maxTrades = arrayData[0];
  let stockPrices = arrayData[1];

  // WHY?
  let tempStr = "[0";
  for (i = 0; i < stockPrices.length; i++) {
    tempStr += ",0";
  }
  tempStr += "]";
  let tempArr = "[" + tempStr;
  for (i = 0; i < maxTrades - 1; i++) {
    tempArr += "," + tempStr;
  }
  tempArr += "]";

  let highestProfit = JSON.parse(tempArr);

  for (i = 0; i < maxTrades; i++) {
    for (j = 0; j < stockPrices.length; j++) { // Buy / Start
      for (k = j; k < stockPrices.length; k++) { // Sell / End
        if (i > 0 && j > 0 && k > 0) {
          highestProfit[i][k] = Math.max(highestProfit[i][k], highestProfit[i - 1][k], highestProfit[i][k - 1], highestProfit[i - 1][j - 1] + stockPrices[k] - stockPrices[j]);
        } else if (i > 0 && j > 0) {
          highestProfit[i][k] = Math.max(highestProfit[i][k], highestProfit[i - 1][k], highestProfit[i - 1][j - 1] + stockPrices[k] - stockPrices[j]);
        } else if (i > 0 && k > 0) {
          highestProfit[i][k] = Math.max(highestProfit[i][k], highestProfit[i - 1][k], highestProfit[i][k - 1], stockPrices[k] - stockPrices[j]);
        } else if (j > 0 && k > 0) {
          highestProfit[i][k] = Math.max(highestProfit[i][k], highestProfit[i][k - 1], stockPrices[k] - stockPrices[j]);
        } else {
          highestProfit[i][k] = Math.max(highestProfit[i][k], stockPrices[k] - stockPrices[j]);
        }
      }
    }
  }
  return highestProfit[maxTrades - 1][stockPrices.length - 1];
}

const stockMarketProfit = (stocks, maxTransactions = stocks.length - 1) => {
  const n = stocks.length;
  const k = maxTransactions;
  const table = Array.from({ length: k + 1 }, () => Array.from({ length: n + 1 }, () => 0));

  // For each number of transactions.
  for (let t = 1; t <= k; t++) {
    // For each day.
    for (let d = 1; d < n; d++) {
      let max = Number.NEGATIVE_INFINITY;

      // For each day up to this day.
      for (let l = 0; l < d; l++) {
        // Take the current max, or the profit from this sale plus the maximum profit
        // of t-1 transactions up until this point.
        max = Math.max(max, stocks[d] - stocks[l] + table[t - 1][l]);
      }

      // But don't go backward (in case this is a negative transaction).
      table[t][d] = Math.max(max, table[t][d - 1]);
    }
  }

  return table[k][n - 1];
};

//SMALLEST TRIANGLE SUM

function solveTriangleSum(arrayData, ns) {
  let triangle = arrayData;
  let nextArray;
  let previousArray = triangle[0];

  for (let i = 1; i < triangle.length; i++) {
    nextArray = [];
    for (let j = 0; j < triangle[i].length; j++) {
      if (j == 0) {
        nextArray.push(previousArray[j] + triangle[i][j]);
      } else if (j == triangle[i].length - 1) {
        nextArray.push(previousArray[j - 1] + triangle[i][j]);
      } else {
        nextArray.push(Math.min(previousArray[j], previousArray[j - 1]) + triangle[i][j]);
      }

    }

    previousArray = nextArray;
  }

  return Math.min.apply(null, nextArray);
}

//UNIQUE PATHS IN A GRID

function uniquePathsI(grid) {
  const rightMoves = grid[0] - 1;
  const downMoves = grid[1] - 1;

  return Math.round(factorialDivision(rightMoves + downMoves, rightMoves) / (factorial(downMoves)));
}

function factorial(n) {
  return factorialDivision(n, 1);
}

function factorialDivision(n, d) {
  if (n == 0 || n == 1 || n == d)
    return 1;
  return factorialDivision(n - 1, d) * n;
}

function uniquePathsII(grid, ignoreFirst = false, ignoreLast = false) {
  const rightMoves = grid[0].length - 1;
  const downMoves = grid.length - 1;

  let totalPossiblePaths = Math.round(factorialDivision(rightMoves + downMoves, rightMoves) / (factorial(downMoves)));

  for (let i = 0; i < grid.length; i++) {
    for (let j = 0; j < grid[i].length; j++) {

      if (grid[i][j] == 1 && (!ignoreFirst || (i != 0 || j != 0)) && (!ignoreLast || (i != grid.length - 1 || j != grid[i].length - 1))) {
        const newArray = [];
        for (let k = i; k < grid.length; k++) {
          newArray.push(grid[k].slice(j, grid[i].length));
        }

        let removedPaths = uniquePathsII(newArray, true, ignoreLast);
        removedPaths *= uniquePathsI([i + 1, j + 1]);

        totalPossiblePaths -= removedPaths;
      }
    }

  }

  return totalPossiblePaths;
}

//GENERATE IP ADDRESSES

function generateIps(num) {
  num = num.toString();

  const length = num.length;

  const ips = [];

  for (let i = 1; i < length - 2; i++) {
    for (let j = i + 1; j < length - 1; j++) {
      for (let k = j + 1; k < length; k++) {
        const ip = [
          num.slice(0, i),
          num.slice(i, j),
          num.slice(j, k),
          num.slice(k, num.length)
        ];
        let isValid = true;

        ip.forEach(seg => {
          isValid = isValid && isValidIpSegment(seg);
        });

        if (isValid) ips.push(ip.join("."));

      }

    }
  }

  return ips;

}

function isValidIpSegment(segment) {
  if (segment[0] == "0" && segment !== "0") return false;
  segment = Number(segment);
  if (segment < 0 || segment > 255) return false;
  return true;
}

//GREATEST FACTOR

function factor(num) {
  for (let div = 2; div <= Math.sqrt(num); div++) {
    if (num % div != 0) {
      continue;
    }
    num = num / div;
    div = 2;
  }
  return num;
}

//SPIRALIZE Matrix

function spiral(arr, accum = []) {
  if (arr.length === 0 || arr[0].length === 0) {
    return accum;
  }
  accum = accum.concat(arr.shift());
  if (arr.length === 0 || arr[0].length === 0) {
    return accum;
  }
  accum = accum.concat(column(arr, arr[0].length - 1));
  if (arr.length === 0 || arr[0].length === 0) {
    return accum;
  }
  accum = accum.concat(arr.pop().reverse());
  if (arr.length === 0 || arr[0].length === 0) {
    return accum;
  }
  accum = accum.concat(column(arr, 0).reverse());
  if (arr.length === 0 || arr[0].length === 0) {
    return accum;
  }
  return spiral(arr, accum);
}

function column(arr, index) {
  const res = [];
  for (let i = 0; i < arr.length; i++) {
    const elm = arr[i].splice(index, 1)[0];
    if (elm) {
      res.push(elm);
    }
  }
  return res;
}

// Merge Overlapping Intervals

function mergeOverlap(intervals) {
  intervals.sort(([minA], [minB]) => minA - minB);
  for (let i = 0; i < intervals.length; i++) {
    for (let j = i + 1; j < intervals.length; j++) {
      const [min, max] = intervals[i];
      const [laterMin, laterMax] = intervals[j];
      if (laterMin <= max) {
        const newMax = laterMax > max ? laterMax : max;
        const newInterval = [min, newMax];
        intervals[i] = newInterval;
        intervals.splice(j, 1);
        j = i;
      }
    }
  }
  return intervals;
}
